{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///farse.min.js","webpack:///webpack/bootstrap 758d8525d42049b764b4","webpack:///./src/farse.js","webpack:///./src/unfarse.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","closeOf","prev","ch","openClose","parsingContext","stack","last","length","peach","str","iter","matchesLast","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","pop","close","push","err","parseParamStr","params","curParam","parseArrow","source","left","right","hitArrow","slice","trim","paramStr","startsWith","body","name","kind","parseNormal","trimLeft","bodyStr","farse","fn","Function","prototype","toString","(","[","{","\"","'","//","/*","inverse","_toConsumableArray","arr","Array","isArray","i","arr2","from","isArrow","parsed","isGenerator","inexactUnfarse","constructor","GeneratorFunction","bind","apply","concat","exactUnfarse","gap","label","eval","join","regeneratorRuntime","mark","_callee","wrap","_context","stop","inexact","exact"],"mappings":"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","file":"farse.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"farse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"farse\"] = factory();\n\telse\n\t\troot[\"farse\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"farse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"farse\"] = factory();\n\telse\n\t\troot[\"farse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar openClose = {\n\t  '(': ')',\n\t  '[': ']',\n\t  '{': '}',\n\t  '\"': '\"',\n\t  \"'\": \"'\",\n\t  '//': '\\n',\n\t  '/*': '*/'\n\t};\n\tfunction closeOf(prev, ch) {\n\t  return prev === '/' ? openClose[prev + ch] : openClose[ch];\n\t}\n\t\n\tfunction parsingContext(stack) {\n\t  var last = stack[stack.length - 1];\n\t  if (last === '\"' || last === \"'\") return 'String';else if (last === '*/' || last === '\\n') return 'Comment';else return 'Code';\n\t}\n\t\n\tfunction peach(str, iter) {\n\t  var stack = [];\n\t  function matchesLast(str) {\n\t    return str === stack[stack.length - 1];\n\t  }\n\t  var prev = void 0;\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = str[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var ch = _step.value;\n\t\n\t      iter(ch, stack);\n\t      if (parsingContext(stack) === 'String') {\n\t        if (prev !== '\\\\' && matchesLast(ch)) stack.pop();\n\t      } else if (parsingContext(stack) === 'Comment') {\n\t        if (matchesLast(ch) || matchesLast(prev + ch)) stack.pop();\n\t      } else {\n\t        if (matchesLast(ch)) stack.pop();else {\n\t          var close = closeOf(prev, ch);\n\t          if (close) stack.push(close);\n\t        }\n\t      }\n\t      prev = ch;\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseParamStr(str) {\n\t  var params = [];\n\t  var curParam = '';\n\t  peach(str, function (ch, stack) {\n\t    if (parsingContext(stack) === 'Code' && ch === ',') {\n\t      params.push(curParam);\n\t      curParam = '';\n\t    } else {\n\t      curParam += ch;\n\t    }\n\t  });\n\t  if (curParam) params.push(curParam);\n\t  return params;\n\t}\n\t\n\tfunction parseArrow(source) {\n\t  var left = '',\n\t      right = '',\n\t      hitArrow = false;\n\t  var prev = void 0;\n\t  peach(source, function (ch, stack) {\n\t    if (hitArrow) right += ch;else if (stack.length === 0 && prev + ch === '=>') {\n\t      left = left.slice(0, -1);\n\t      hitArrow = true;\n\t    } else left += ch;\n\t    prev = ch;\n\t  });\n\t  left = left.trim();\n\t  var paramStr = left.startsWith('(') ? left.slice(1, -1) : left;\n\t  right = right.trim();\n\t  var body = right.startsWith('{') ? right.slice(1, -1) : 'return ' + right + ';';\n\t  return {\n\t    name: '',\n\t    params: parseParamStr(paramStr),\n\t    body: body,\n\t    kind: 'ArrowFunction'\n\t  };\n\t}\n\t\n\tfunction parseNormal(source) {\n\t  source = source.slice(8).trimLeft(); // drop 'function' part\n\t  var name = '',\n\t      paramStr = '',\n\t      bodyStr = '',\n\t      kind = 'StandardFunction';\n\t  if (source.startsWith('*')) {\n\t    kind = 'GeneratorFunction';\n\t    source = source.slice(1);\n\t  }\n\t  while (source[0] !== '(') {\n\t    name += source[0];\n\t    source = source.slice(1);\n\t  }\n\t  peach(source, function (ch, stack) {\n\t    if (stack[0] === ')') paramStr += ch;else if (stack[0] === '}') bodyStr += ch;\n\t  });\n\t  return {\n\t    name: name.trim(),\n\t    params: parseParamStr(paramStr.slice(0, -1)),\n\t    body: bodyStr.slice(0, -1),\n\t    kind: kind\n\t  };\n\t}\n\t\n\tfunction farse(fn) {\n\t  var source = Function.prototype.toString.call(fn);\n\t  return source.startsWith('function') ? parseNormal(source) : parseArrow(source);\n\t}\n\t\n\tfarse.inverse = __webpack_require__(1);\n\t\n\tmodule.exports = farse;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction isArrow(parsed) {\n\t  return parsed.kind === 'ArrowFunction';\n\t}\n\t\n\tfunction isGenerator(parsed) {\n\t  return parsed.kind === 'GeneratorFunction';\n\t}\n\t\n\tvar GeneratorFunction = /* istanbul ignore next */regeneratorRuntime.mark(function _callee() {\n\t  return regeneratorRuntime.wrap(function _callee$(_context) {\n\t    while (1) {\n\t      switch (_context.prev = _context.next) {\n\t        case 0:\n\t        case 'end':\n\t          return _context.stop();\n\t      }\n\t    }\n\t  }, _callee, this);\n\t}).constructor;\n\t\n\tfunction inexactUnfarse(parsed) {\n\t  var constructor = isGenerator(parsed) ? GeneratorFunction : Function;\n\t  return new (Function.prototype.bind.apply(constructor, [null].concat(_toConsumableArray(parsed.params), [parsed.body])))();\n\t}\n\t\n\tfunction exactUnfarse(parsed) {\n\t  // beware: uses `eval`\n\t  var gap = isArrow(parsed) ? '=>' : ' ';\n\t  var label = isArrow(parsed) ? '' : 'function' + (isGenerator(parsed) ? '*' : '') + ' ' + parsed.name;\n\t  return eval('(' + label + '(' + parsed.params.join(',') + ')' + gap + '{' + parsed.body + '})');\n\t};\n\t\n\tmodule.exports = {\n\t  inexact: inexactUnfarse,\n\t  exact: exactUnfarse\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** farse.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 758d8525d42049b764b4\n **/","'use strict';\n\nconst openClose = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  '\"': '\"',\n  \"'\": \"'\",\n  '//': '\\n',\n  '/*': '*/'\n};\nfunction closeOf (prev, ch) {\n  return prev === '/' ? openClose[prev+ch] : openClose[ch];\n}\n\nfunction parsingContext (stack) {\n  const last = stack[stack.length-1];\n  if (last === '\"' || last === \"'\") return 'String';\n  else if (last === '*/' || last === '\\n') return 'Comment';\n  else return 'Code';\n}\n\nfunction peach (str, iter) {\n  const stack = [];\n  function matchesLast (str) {\n    return str === stack[stack.length-1];\n  }\n  let prev;\n  for (let ch of str) {\n    iter(ch, stack);\n    if (parsingContext(stack) === 'String') {\n      if (prev !== '\\\\' && matchesLast(ch)) stack.pop();\n    } else if (parsingContext(stack) === 'Comment') {\n      if (matchesLast(ch) || matchesLast(prev+ch)) stack.pop();\n    } else {\n      if (matchesLast(ch)) stack.pop();\n      else {\n        let close = closeOf(prev, ch);\n        if (close) stack.push(close);\n      }\n    }\n    prev = ch;\n  }\n}\n\nfunction parseParamStr (str) {\n  const params = [];\n  let curParam = '';\n  peach(str, function (ch, stack) {\n    if (parsingContext(stack) === 'Code' && ch === ',') {\n      params.push(curParam);\n      curParam = '';\n    } else {\n      curParam += ch;\n    }\n  });\n  if (curParam) params.push(curParam);\n  return params;\n}\n\nfunction parseArrow (source) {\n  let left = '', right = '', hitArrow = false;\n  let prev;\n  peach(source, function (ch, stack) {\n    if (hitArrow) right += ch;\n    else if (stack.length === 0 && prev + ch === '=>') {\n      left = left.slice(0,-1);\n      hitArrow = true;\n    } else left += ch;\n    prev = ch;\n  });\n  left = left.trim();\n  const paramStr = left.startsWith('(') ? left.slice(1,-1) : left;\n  right = right.trim();\n  const body = right.startsWith('{') ? right.slice(1,-1) : `return ${right};`;\n  return {\n    name: '',\n    params: parseParamStr(paramStr),\n    body: body,\n    kind: 'ArrowFunction'\n  };\n}\n\nfunction parseNormal (source) {\n  source = source.slice(8).trimLeft(); // drop 'function' part\n  let name = '', paramStr = '', bodyStr = '', kind = 'StandardFunction';\n  if (source.startsWith('*')) {\n    kind = 'GeneratorFunction';\n    source = source.slice(1);\n  }\n  while (source[0] !== '(') {\n    name += source[0];\n    source = source.slice(1);\n  }\n  peach(source, function (ch, stack) {\n    if (stack[0] === ')') paramStr += ch;\n    else if (stack[0] === '}') bodyStr += ch;\n  });\n  return {\n    name: name.trim(),\n    params: parseParamStr(paramStr.slice(0,-1)),\n    body: bodyStr.slice(0,-1),\n    kind\n  };\n}\n\nfunction farse (fn) {\n  const source = Function.prototype.toString.call(fn);\n  return source.startsWith('function') ? parseNormal(source) : parseArrow(source);\n}\n\nfarse.inverse = require('./unfarse');\n\nmodule.exports = farse;\n\n\n/** WEBPACK FOOTER **\n ** ./src/farse.js\n **/","'use strict';\n\nfunction isArrow (parsed) {\n  return parsed.kind === 'ArrowFunction';\n}\n\nfunction isGenerator (parsed) {\n  return parsed.kind === 'GeneratorFunction';\n}\n\nconst GeneratorFunction = (/* istanbul ignore next */ function*(){}).constructor;\n\nfunction inexactUnfarse (parsed) {\n  const constructor = isGenerator(parsed) ? GeneratorFunction : Function;\n  return new constructor(...parsed.params, parsed.body);\n}\n\nfunction exactUnfarse (parsed) {\n  // beware: uses `eval`\n  const gap = isArrow(parsed) ? '=>' : ' ';\n  const label = isArrow(parsed) ? '' : `function${isGenerator(parsed)?'*':''} ${parsed.name}`;\n  return eval(`(${label}(${parsed.params.join(',')})${gap}{${parsed.body}})`);\n};\n\nmodule.exports = {\n  inexact: inexactUnfarse,\n  exact: exactUnfarse\n};\n\n\n/** WEBPACK FOOTER **\n ** ./src/unfarse.js\n **/"],"sourceRoot":""}